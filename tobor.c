#pragma config(Sensor, S2,     sonarSensor,         sensorSONAR)
#pragma config(Sensor, S3,     sensorRGB,      sensorColorNxtRED)
#pragma config(Sensor, S4,     sensorLight,    sensorLightActive)
#pragma config(Motor,  motorB,          motorRight,    tmotorNXT, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorC,          motorLeft,     tmotorNXT, PIDControl, driveLeft, encoder)
#pragma platform(NXT)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int LIGHT_TRESHHOLD = 45;
const int STEP_SIZE = 1;
const int MAX_SPEED = 50;
const int MIN_DISTANCE = 20

bool hasSpottedObject = false;

long nLastXmitTimeStamp = nPgmTime;
long nDeltaTime         = 0;

const int kMaxSizeOfMessage = 30;
const int INBOX = 5;

TFileIOResult nBTCmdRdErrorStatus;
int nSizeOfMessage;
ubyte nRcvBuffer[kMaxSizeOfMessage];

void checkBluetoothMessage(string &command) {
  nSizeOfMessage = cCmdMessageGetSize(INBOX);

  if (nSizeOfMessage > kMaxSizeOfMessage)
    nSizeOfMessage = kMaxSizeOfMessage;

  if (nSizeOfMessage > 0){
  	nBTCmdRdErrorStatus = cCmdMessageRead(nRcvBuffer, nSizeOfMessage, INBOX);
  	nRcvBuffer[nSizeOfMessage] = '\0';
  	stringFromChars(command, (char *) nRcvBuffer);
  }
}

void makeSound(){
		playSound(soundUpwardTones);
}

task main() {
	int direction = 0;
	int counter = 0;
	string command = "";

	while (true) {
		checkBluetoothMessage(command);
		displayCenteredBigTextLine(4, command);

		int value = SensorValue[sensorLight];
		int value2 = SensorValue[sensorRGB];
		int value3 = SensorValue[sonarSensor];

		displayTextLine(0, "light: %d", value);
		displayTextLine(1, "RGB: %d", value2);
		displayTextLine(2, "Direction: %d", direction);
		displayTextLine(3, "Sonar sensor: %d", value3);

		if (SensorValue[sonarSensor] < MIN_DISTANCE) {
			hasSpottedObject = true;
		} else if (value2 < LIGHT_TRESHHOLD) {
			direction = 2;
		} else if (value < LIGHT_TRESHHOLD) {
			direction = 1;
		} else {
			direction = 0;
		}


		if (!hasSpottedObject) {
			switch(direction) {
				case 0: // On Track
					motor[motorLeft] = MAX_SPEED;
					motor[motorRight] = MAX_SPEED;
					break;
				case 1: // Turn left
					motor[motorLeft] = 0;
					motor[motorRight] = MAX_SPEED / 2;
					break;
				case 2: // Turn right
					motor[motorLeft] = MAX_SPEED / 2;
					motor[motorRight] = 0;
					break;
			}
		} else {
			nMotorEncoder[motorB] = 0;
			nMotorEncoder[motorC] = 0;

			while (nMotorEncoder[motorRight] > -360 || nMotorEncoder[motorLeft] < 360) {
				displayTextLine(4, "Motor R: %d", nMotorEncoder[motorRight]);
				displayTextLine(5, "Motor L: %d", nMotorEncoder[motorLeft]);

				nMotorEncoderTarget[motorRight] = -360;
				nMotorEncoderTarget[motorLeft] = 360;

				motor[motorLeft] = MAX_SPEED / 2;
				motor[motorRight] = -MAX_SPEED / 2;

				hasSpottedObject = false;
				wait1Msec(1);
			}
		}
	counter++;
	if (counter > 75) {
		makeSound();
		counter = 0;
	}
	wait1Msec(20);
	}
}
